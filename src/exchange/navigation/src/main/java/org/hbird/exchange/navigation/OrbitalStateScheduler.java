package org.hbird.exchange.navigation;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.camel.Body;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.ProducerTemplate;
import org.hbird.exchange.type.D3Vector;
import org.hbird.exchange.type.Location;
import org.hbird.exchange.type.Satellite;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * Component for generating orbital prediction requests at intervals.
 * 
 * An orbital request must define;
 * - name. The name of the prediction request. The same name will be set on the orbital states generated. Can be used to distinguish between for example 'Measured' and 'Predicted' orbital states.
 * - satellite. The satellite for which the prediction is being made.
 * - initialOrbitalState. The state from which the orbit should be predicted. Includes the time, the position and the velocity.
 * - List of Locations. A list of locations for which contact events (established / lost) should be created.
 * - delta propagation. The period for which the prediction should be made.
 * - step size. The size of each step. The number of generated Orbital States will thus be the delta propagation / step size.
 * 
 * Of these, the initialOrbitalState will typically change between each prediction request, i.e. a each prediction
 * will typically be done from the current time, position and velocity. To perform orbital predictions, the scheduler 
 * must thus continuously be (re)configured with the latest state. This can be done in different ways
 * - Orbital states can be routed to the classes 'procesOrbitalState' method. The latest received orbital state will
 *   thereafter be used for the next prediction. 
 * - The position can be routed to the method 'processPosition'. The new position and its timestamp will be set on the
 *   orbital state.
 * - The velocity can be routed to the method 'processVelocity'. The new velocity and its timestamp will be set on the
 *   orbital state.
 * 
 * Notice that the prediction is not performed each time a new orbital state, position or velocity is routed to the
 * bean, but based on a schedule as described below.
 *
 */
public class OrbitalStateScheduler {

	/** Unique UUID */
	private static final long serialVersionUID = -4787275022054480174L;

	/** Queue for the task schedule. */
	@Autowired
	protected ProducerTemplate producer = null;

	/** The context in which the component is running. */
	@Autowired
	protected CamelContext context = null;

	/** The initial state from which the prediction is made. */
	protected OrbitalState initialOrbitalState = null;
	
	/** The satellite for which we calculate the Orbit. */
	protected Satellite satellite = null;
	
	/** The locations for which contact events should be calculated. */
	protected Map<String, Location> locations = null;

	/** The period for which a propagation shal be calculated. The number of orbit predictions will be
	 * deltapropagation / stepSize. */
	protected Double deltaPropagation = 3600.;
	
	/** The interval between each prediction. */
	protected Double stepSize = 60.;

	/** Name of the orbital request. Will also be used for each orbital state generated from a 
	 * request. */
	protected String name = "Measured";

	/** Time stamp (ms) of the last prediction. */
	protected long lastPrediction = 0l;

	/** Frequency (ms) at which predictions should be made. */
	protected long predictionInterval = 24 * 60 * 60 * 1000;
	
	/**
	 * Constructor of an already initialized scheduler.
	 * 
	 * @param name The name of the request generated by the scheduler.
	 * @param satellite The satellite for which orbital states should be calculated.
	 * @param initialOrbitalstate The first orbital state from which a prediction should be created.
	 * @param locations The locations for which contact events is generated.
	 */
	public OrbitalStateScheduler(String name, Satellite satellite, OrbitalState initialOrbitalstate, List<Location> locations) {
		this.name = name;
		this.initialOrbitalState = initialOrbitalstate;
		this.satellite = satellite;

		this.locations = new HashMap<String, Location>();
		for (Location location : locations) {
			this.locations.put(location.getName(), location);
		}
	}

	
	/**
	 *  Method to create a prediction request. The request will only be generated if 
	 *  the current orbital state has been set (i.e. an initial state from which the 
	 *  prediction can be made) and if the prediction interval has expired.
	 * 
	 * @param exchange The exchange triggering the event. The IN body will be set to the 
	 * request, or the route will be stopped.
	 */
	public void process(Exchange exchange) {
		synchronized(this) {
			long now = (new Date()).getTime();
			if (initialOrbitalState != null && now > (lastPrediction + predictionInterval)) {
				OrbitPredictionRequest request = new OrbitPredictionRequest(name, satellite, initialOrbitalState, new ArrayList<Location>(locations.values()));
				request.deltaPropagation = deltaPropagation; 
				request.stepSize = stepSize;
				exchange.getIn().setBody(request);
				lastPrediction = now;
			}
			else {
				exchange.setProperty(Exchange.ROUTE_STOP, true);
			}
		}
	}

	/**
	 * Sets the current orbital state. Should be used to constantly set the 
	 * orbital state to the latest state available. For example the following 
	 * route could be used
	 * 
	 *  <route>
	 *    TODO
	 *  </route>
	 * 
	 * @param exchange The exchange carrying the new orbital state.
	 */
	public void processOrbitalState(@Body OrbitalState newState) {
		synchronized(this) {
			this.initialOrbitalState = newState;
		}
	}	

	
	/**
	 * Set the position of the orbital state to be used to perform predictions.
	 * 
	 * @param newPosition The new position to be used.
	 */
	public void processPosition(@Body D3Vector newPosition) {
		synchronized(this) {
			this.initialOrbitalState.position = newPosition;
			this.initialOrbitalState.setTimestamp(newPosition.getTimestamp());
		}
	}	

	
	/**
	 * Set the velocity of the orbital state to be used to perform predictions. 
	 * 
	 * @param newVelocity The new velocity to be used.
	 */
	public void processVelocity(@Body D3Vector newVelocity) {
		synchronized(this) {
			this.initialOrbitalState.velocity = newVelocity;
			this.initialOrbitalState.setTimestamp(newVelocity.getTimestamp());
		}
	}	

	/**
	 * Adds a position to the list of positions for which contact events should be generated.
	 * 
	 * @param location
	 */
	public void processLocation(@Body Location location) {
		synchronized(this) {
			locations.put(location.getName(), location);		
		}
	}

	/**
	 * Sets the interval between predictions. 
	 * 
	 * @param predictionInterval The new interval (ms) to be used
	 */
	public void setPredictionInterval(long predictionInterval) {
		this.predictionInterval = predictionInterval;
	}

	/**
	 * Sets the interval for which predictions shall be made.
	 * 
	 * @param deltaPropagation
	 */
	public void setDeltaPropagation(Double deltaPropagation) {
		this.deltaPropagation = deltaPropagation;
	}

	/**
	 * Sets the size of each step when performing predictions.
	 * 
	 * @param stepSize Size (ms) of each step.
	 */
	public void setStepSize(Double stepSize) {
		this.stepSize = stepSize;
	}
}
